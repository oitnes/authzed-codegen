package generator

import (
	"bytes"
	_ "embed"
	"fmt"
	"os"
	"strings"
	"text/template"

	zedlexer "github.com/oitnes/authzed-codegen/internal/generator/zed_lexer"
)

//go:embed object.go.tmpl
var objectTemplate []byte

const (
	objectTemplateName = "[object]"
	sourceHeader       = "// Code generated by spicedb-gen, DO NOT EDIT.\n\n"
)

// Expression represents different types of expressions in the schema
type Expression interface {
	String() string
}

// IdentifierNode represents an identifier in expressions
type IdentifierNode struct {
	Value string
}

func (n *IdentifierNode) String() string {
	return n.Value
}

// BinaryOpNode represents binary operations like +, ->, etc.
type BinaryOpNode struct {
	Operator string
	Left     Expression
	Right    Expression
}

func (n *BinaryOpNode) String() string {
	if n.Operator == "->" {
		return fmt.Sprintf("%s->%s", n.Left.String(), n.Right.String())
	}
	return fmt.Sprintf("%s %s %s", n.Left.String(), n.Operator, n.Right.String())
}

// SingleRelation represents a single relation type
type SingleRelation struct {
	Value string
}

func (r *SingleRelation) String() string {
	return r.Value
}

// UnionRelation represents union of relations (|)
type UnionRelation struct {
	Left  Expression
	Right Expression
}

func (r *UnionRelation) String() string {
	return fmt.Sprintf("%s | %s", r.Left.String(), r.Right.String())
}

// RelationNode represents a relation definition
type RelationNode struct {
	Name       string
	Expression Expression
}

// PermissionNode represents a permission definition
type PermissionNode struct {
	Name       string
	Expression Expression
}

// Definition represents a complete definition with relations and permissions
type Definition struct {
	Name        string
	Prefixes    []string
	Relations   []RelationNode
	Permissions []PermissionNode
	ObjectType  *ObjectTypeNode // for template compatibility
}

func (d *Definition) GetObjectType() *ObjectTypeNode {
	prefix := ""
	if len(d.Prefixes) > 0 {
		prefix = strings.Join(d.Prefixes, "/")
	}
	return &ObjectTypeNode{Name: d.Name, Prefix: prefix}
}

// ObjectTypeNode for template compatibility
type ObjectTypeNode struct {
	Name   string
	Prefix string
}

func (o *ObjectTypeNode) String() string {
	if o.Prefix == "" {
		return o.Name
	}
	return o.Prefix + "/" + o.Name
}

// Permission and Relation types for processing
type Permission struct {
	Types []string
	Kind  string
	Value string
}

type Relation struct {
	Types []string
	Kind  string
	Value string
}

type (
	Permissions        []Permission
	PermissionsByNames map[string]Permissions
	Relations          []Relation
	RelationsByNames   map[string]Relations
	DefinitionsByTypes map[string]*ProcessedDefinition
)

type ProcessedDefinition struct {
	Type        string
	Permissions PermissionsByNames
	Relations   RelationsByNames
}

func (p PermissionsByNames) IsEmpty() bool {
	return len(p) == 0
}

func (p PermissionsByNames) Get(permission string) (bool, Permissions) {
	if perms, ok := p[permission]; ok {
		return true, perms
	}
	return false, []Permission{}
}

func (r RelationsByNames) Get(relation string) (bool, Relations) {
	if rels, ok := r[relation]; ok {
		return true, rels
	}
	return false, []Relation{}
}

func (r Relations) Types() []string {
	types := []string{}
	for _, rel := range r {
		types = append(types, rel.Types...)
	}
	return types
}

// Parser interface and implementation
type Parser interface {
	ParseDefinitions() ([]Definition, error)
}

type parser struct {
	tokens  []zedlexer.Token
	current int
}

// NewParser creates a new parser from input string
func NewParser(input string) Parser {
	lexer := &zedlexer.Lexer{InputCode: input}
	return &parser{tokens: filterComments(lexer.Lex())}
}

func filterComments(inputTokens []zedlexer.Token) (outputTokens []zedlexer.Token) {
	for _, t := range inputTokens {
		if t.Type == zedlexer.COMMENT {
			continue
		}
		outputTokens = append(outputTokens, t)
	}
	return
}

// GenerateCodeFromString parses input string and generates code
func GenerateCodeFromString(input, outputFolderPath string) error {
	parser := NewParser(input)
	definitions, err := parser.ParseDefinitions()
	if err != nil {
		return fmt.Errorf("parsing error: %w", err)
	}

	return GenerateCodeTo(definitions, outputFolderPath)
}

func GenerateCodeTo(definitions []Definition, outputFolderPath string) error {
	// Transform definitions for permission tree creation
	transformedDefs := transformDefinitions(definitions)
	permissionsTree := makePermissionTree(transformedDefs)

	tmplFuncMap := template.FuncMap{
		"upperFirst":              UpperFirst,
		"packageName":             PackageName,
		"snakeToPascal":           SnakeToPascal,
		"typeName":                TypeName,
		"typeNameWithUnderscores": TypeNameWithUnderscores,
		"relationExpressionTypes": flattenRelationExpressionTypeStrings,
		"permissionInputTypes": func(objectType string, perm string) []string {
			treeName := fmt.Sprintf("%s/%s", objectType, perm)
			if types, ok := permissionsTree[treeName]; ok {
				return types
			}
			return []string{}
		},
	}

	tmpl := template.New(objectTemplateName).Funcs(tmplFuncMap)
	tmpl, tmplErr := tmpl.Parse(string(objectTemplate))
	if tmplErr != nil {
		return tmplErr
	}

	for _, def := range definitions {
		path := outputFolderPath

		prefixesStr := strings.Join(def.Prefixes, "/")
		if prefixesStr != "" {
			path = fmt.Sprintf("%s/%s", outputFolderPath, PackageName(prefixesStr))
		}

		err := os.MkdirAll(path, os.ModePerm)
		if err != nil && !os.IsExist(err) {
			return err
		}

		buf := bytes.Buffer{}
		if _, err = buf.WriteString(sourceHeader); err != nil {
			return err
		}

		err = tmpl.Execute(&buf, def)
		if err != nil {
			return fmt.Errorf("template execution error for %s: %w", def.Name, err)
		}

		filePath := fmt.Sprintf("%s/%s_gen.go", path, PackageName(def.Name))
		if err := os.WriteFile(filePath, buf.Bytes(), 0o600); err != nil {
			return err
		}
	}

	return nil
}

func UpperFirst(s string) string {
	if s == "" {
		return s
	}

	return strings.ToUpper(s[:1]) + s[1:]
}

func PackageName(s string) string {
	s = strings.ReplaceAll(s, "-", "")
	s = strings.ReplaceAll(s, "_", "")
	return strings.ToLower(s)
}

func Quote(s string) string {
	return "\"" + s + "\""
}

func SnakeToPascal(s string) string {
	var b strings.Builder
	words := strings.Split(s, "_")
	for _, word := range words {
		b.WriteString(UpperFirst(word))
	}
	return b.String()
}

func Length(list []any) string {
	return fmt.Sprintf("%d", len(list))
}

func TypeName(objectType string) string {
	name := strings.Split(objectType, "/")
	if len(name) == 0 {
		return ""
	}
	if len(name) == 1 {
		return UpperFirst(PackageName(name[0]))
	}
	return UpperFirst(PackageName(name[1]))
}

// TypeNameWithUnderscores creates a type name that matches the generated struct names
func TypeNameWithUnderscores(objectType string) string {
	name := strings.Split(objectType, "/")
	var typeName string
	if len(name) == 0 {
		return ""
	}
	if len(name) == 1 {
		typeName = name[0]
	} else {
		typeName = name[len(name)-1]
	}

	// Convert snake_case to match current convention (e.g., "private_forum" -> "Private_forum")
	// Only capitalize the first letter, keep the rest lowercase with underscores
	return UpperFirst(strings.ToLower(typeName))
}

// Parser implementation
func (p *parser) ParseDefinitions() ([]Definition, error) {
	var definitions []Definition
	p.current = 0

	// Check for illegal tokens
	for _, t := range p.tokens {
		if t.Type == zedlexer.ILLEGAL {
			return definitions, fmt.Errorf("found illegal token at line: %d, column: %d", t.Line, t.Column)
		}
	}

	for p.haveNext() {
		def, err := p.parseDefinition()
		if err != nil {
			return nil, err
		}
		definitions = append(definitions, def)
	}

	return definitions, nil
}

func (p *parser) parseDefinition() (Definition, error) {
	var def Definition

	if !p.tryConsume(zedlexer.DEFINITION) {
		return def, p.error("expected definition")
	}

	identifier := p.peek()
	if identifier.Type != zedlexer.IDENTIFIER {
		return def, p.error("expected identifier")
	}
	p.advance()

	parts := strings.Split(identifier.Literal, "/")
	if len(parts) == 0 {
		return def, p.error("expected non-empty identifier")
	}

	def.Name = parts[len(parts)-1]
	if len(parts) > 1 {
		def.Prefixes = parts[:len(parts)-1]
	}
	def.ObjectType = def.GetObjectType()

	if !p.tryConsume(zedlexer.LBRACE) {
		return def, p.error("expected left brace")
	}

	for p.peek().Type == zedlexer.RELATION || p.peek().Type == zedlexer.PERMISSION {
		if p.peek().Type == zedlexer.RELATION {
			rel, err := p.parseRelation()
			if err != nil {
				return def, err
			}
			def.Relations = append(def.Relations, rel)
		} else {
			perm, err := p.parsePermission()
			if err != nil {
				return def, err
			}
			def.Permissions = append(def.Permissions, perm)
		}
	}

	if !p.tryConsume(zedlexer.RBRACE) {
		return def, p.error("expected right brace")
	}

	return def, nil
}

func (p *parser) parseRelation() (RelationNode, error) {
	var rel RelationNode

	if !p.tryConsume(zedlexer.RELATION) {
		return rel, p.error("expected relation")
	}

	identifier := p.peek()
	if identifier.Type != zedlexer.IDENTIFIER {
		return rel, p.error("expected relation identifier")
	}
	p.advance()
	rel.Name = identifier.Literal

	if !p.tryConsume(zedlexer.COLON) {
		return rel, p.error("expected colon")
	}

	expr, err := p.parseRelationExpression()
	if err != nil {
		return rel, err
	}
	rel.Expression = expr

	return rel, nil
}

func (p *parser) parseRelationExpression() (Expression, error) {
	left, err := p.parseSingleRelation()
	if err != nil {
		return nil, err
	}

	for p.peek().Type == zedlexer.OR {
		p.advance() // consume |
		right, err := p.parseSingleRelation()
		if err != nil {
			return nil, err
		}
		left = &UnionRelation{Left: left, Right: right}
	}

	// Handle wildcard
	if p.peek().Type == zedlexer.WILDCARD {
		p.advance()
	}

	return left, nil
}

func (p *parser) parseSingleRelation() (Expression, error) {
	identifier := p.peek()
	if identifier.Type != zedlexer.IDENTIFIER {
		return nil, p.error("expected relation identifier")
	}
	p.advance()

	return &SingleRelation{Value: identifier.Literal}, nil
}

func (p *parser) parsePermission() (PermissionNode, error) {
	var perm PermissionNode

	if !p.tryConsume(zedlexer.PERMISSION) {
		return perm, p.error("expected permission")
	}

	identifier := p.peek()
	if identifier.Type != zedlexer.IDENTIFIER {
		return perm, p.error("expected permission identifier")
	}
	p.advance()
	perm.Name = identifier.Literal

	if !p.tryConsume(zedlexer.EQUAL) {
		return perm, p.error("expected equal")
	}

	expr, err := p.parsePermissionExpression()
	if err != nil {
		return perm, err
	}
	perm.Expression = expr

	return perm, nil
}

func (p *parser) parsePermissionExpression() (Expression, error) {
	return p.parseAdditiveExpression()
}

func (p *parser) parseAdditiveExpression() (Expression, error) {
	left, err := p.parseMultiplicativeExpression()
	if err != nil {
		return nil, err
	}

	for p.peek().Type == zedlexer.PLUS || p.peek().Type == zedlexer.MINUS {
		op := p.peek().Literal
		p.advance()
		right, err := p.parseMultiplicativeExpression()
		if err != nil {
			return nil, err
		}
		left = &BinaryOpNode{Operator: op, Left: left, Right: right}
	}

	return left, nil
}

func (p *parser) parseMultiplicativeExpression() (Expression, error) {
	left, err := p.parsePrimaryExpression()
	if err != nil {
		return nil, err
	}

	for p.peek().Type == zedlexer.AND {
		op := p.peek().Literal
		p.advance()
		right, err := p.parsePrimaryExpression()
		if err != nil {
			return nil, err
		}
		left = &BinaryOpNode{Operator: op, Left: left, Right: right}
	}

	return left, nil
}

func (p *parser) parsePrimaryExpression() (Expression, error) {
	if p.peek().Type == zedlexer.LBRACKETS {
		return p.parseParenthesizedExpression()
	}
	return p.parseIdentifierChain()
}

func (p *parser) parseParenthesizedExpression() (Expression, error) {
	if !p.tryConsume(zedlexer.LBRACKETS) {
		return nil, p.error("expected left parenthesis")
	}

	expr, err := p.parseAdditiveExpression()
	if err != nil {
		return nil, err
	}

	if !p.tryConsume(zedlexer.RBRACKETS) {
		return nil, p.error("expected right parenthesis")
	}

	return expr, nil
}

func (p *parser) parseIdentifierChain() (Expression, error) {
	identifier := p.peek()
	if identifier.Type != zedlexer.IDENTIFIER {
		return nil, p.error("expected identifier")
	}
	p.advance()

	var left Expression = &IdentifierNode{Value: identifier.Literal}

	for p.peek().Type == zedlexer.ARROW {
		op := p.peek().Literal
		p.advance()
		right := p.peek()
		if right.Type != zedlexer.IDENTIFIER {
			return nil, p.error("expected identifier after arrow")
		}
		p.advance()
		left = &BinaryOpNode{Operator: op, Left: left, Right: &IdentifierNode{Value: right.Literal}}
	}

	return left, nil
}

// Helper methods
func (p *parser) tryConsume(expected zedlexer.TokenType) bool {
	if p.peek().Type == expected {
		p.advance()
		return true
	}
	return false
}

func (p *parser) advance() {
	p.current++
}

func (p *parser) haveNext() bool {
	return p.current < len(p.tokens) && p.peek().Type != zedlexer.EOF
}

func (p *parser) peek() zedlexer.Token {
	if p.current >= len(p.tokens) {
		return zedlexer.Token{Type: zedlexer.EOF}
	}
	return p.tokens[p.current]
}

func (p *parser) error(msg string) error {
	token := p.peek()
	return fmt.Errorf("line %d, column %d: %s", token.Line, token.Column, msg)
}

// Transform functions
func transformDefinitions(defs []Definition) DefinitionsByTypes {
	defsByTypes := DefinitionsByTypes{}

	for _, d := range defs {
		objectType := d.GetObjectType().String()
		_permissions := PermissionsByNames{}
		_relations := RelationsByNames{}

		for _, p := range d.Permissions {
			_permissions[p.Name] = Permissions{}
		}

		for _, r := range d.Relations {
			_relations[r.Name] = flattenRelationExpressionTypes(r.Expression)
		}

		defsByTypes[objectType] = &ProcessedDefinition{
			Type:        objectType,
			Permissions: _permissions,
			Relations:   _relations,
		}
	}

	for _, d := range defs {
		objectType := d.GetObjectType().String()
		_permissions := PermissionsByNames{}

		for _, p := range d.Permissions {
			_permissions[p.Name] = resolvePermissionExpressionTypes(p.Expression, ResolveArgs{
				ObjectType:  objectType,
				Definitions: defsByTypes,
			})
		}

		defsByTypes[objectType].Permissions = _permissions
	}

	return defsByTypes
}

func flattenRelationExpressionTypeStrings(expr Expression) []string {
	result := []string{}
	for _, r := range flattenRelationExpressionTypes(expr) {
		result = append(result, r.Types...)
	}
	return result
}

func flattenRelationExpressionTypes(expr Expression) []Relation {
	result := []Relation{}

	switch node := expr.(type) {
	case *SingleRelation:
		result = append(result, Relation{
			Types: []string{node.Value},
			Kind:  "single",
			Value: node.Value,
		})
	case *UnionRelation:
		if node.Left != nil {
			result = append(result, flattenRelationExpressionTypes(node.Left)...)
		}
		if node.Right != nil {
			result = append(result, flattenRelationExpressionTypes(node.Right)...)
		}
	}

	return result
}

type ResolveArgs struct {
	ObjectType  string
	Definitions DefinitionsByTypes
}

func resolvePermissionExpressionTypes(expr Expression, args ResolveArgs) []Permission {
	permissions := []Permission{}

	_relations := args.Definitions[args.ObjectType].Relations
	_permissions := args.Definitions[args.ObjectType].Permissions

	switch node := expr.(type) {
	case *IdentifierNode:
		if ok, rels := _relations.Get(node.Value); ok {
			permissions = append(permissions, Permission{
				Types: rels.Types(),
				Kind:  "relation",
				Value: node.Value,
			})
		} else if ok, _ := _permissions.Get(node.Value); ok {
			permissions = append(permissions, Permission{
				Types: []string{args.ObjectType},
				Kind:  "permission",
				Value: node.Value,
			})
		}

	case *BinaryOpNode:
		if node.Operator == "->" {
			permission := node.Right.String()
			_, relations := _relations.Get(node.Left.String())
			for _, referenceType := range relations.Types() {
				if refDef, exists := args.Definitions[referenceType]; exists && refDef != nil {
					ok, _ := refDef.Permissions.Get(permission)
					if ok {
						permissions = append(permissions, Permission{
							Types: []string{referenceType},
							Kind:  "permission",
							Value: permission,
						})
					}
				}
			}
		} else {
			if node.Left != nil {
				permissions = append(permissions, resolvePermissionExpressionTypes(node.Left, args)...)
			}
			if node.Right != nil {
				permissions = append(permissions, resolvePermissionExpressionTypes(node.Right, args)...)
			}
		}
	}

	// Deduplicate
	deduped := []Permission{}
	seen := map[string]bool{}
	for _, p := range permissions {
		uniq := strings.Join(p.Types, ",") + p.Kind + p.Value
		if _, ok := seen[uniq]; !ok {
			seen[uniq] = true
			deduped = append(deduped, p)
		}
	}

	return deduped
}

func makePermissionTree(d DefinitionsByTypes) map[string][]string {
	tree := map[string][]string{}
	seen := map[string]bool{}

	addTree := func(treeName string, types []string) {
		for _, t := range types {
			seenName := fmt.Sprintf("%s/%s", treeName, t)
			if _, ok := seen[seenName]; !ok {
				seen[seenName] = true
				tree[treeName] = append(tree[treeName], t)
			}
		}
	}

	// Creating a relation resolver
	relationResolver := map[string][]string{}
	for t, def := range d {
		if def.Permissions.IsEmpty() {
			tree[t] = []string{}
		}

		for n, permissions := range def.Permissions {
			for _, p := range permissions {
				if p.Kind == "relation" {
					treename := fmt.Sprintf("%s/%s", t, n)
					relationResolver[treename] = p.Types
				}
			}
		}
	}

	// Find all references
	for t, def := range d {
		for n, permissions := range def.Permissions {
			for _, p := range permissions {
				treename := fmt.Sprintf("%s/%s", t, n)
				if p.Kind == "permission" {
					for _, ref := range p.Types {
						refperm := fmt.Sprintf("%s/%s", ref, p.Value)
						addTree(treename, relationResolver[refperm])
					}
				} else {
					addTree(treename, p.Types)
				}
			}
		}
	}

	return tree
}
